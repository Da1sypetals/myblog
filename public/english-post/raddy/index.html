<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['$', '$']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Raddy devlog: forward autodiff system | Da1sypetals</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="http://localhost:1313/english-post/raddy/">
  <meta property="og:site_name" content="Da1sypetals">
  <meta property="og:title" content="Raddy devlog: forward autodiff system">
  <meta property="og:description" content="TL;DR: I created Raddy, a forward autodiff library, and Symars, a symbolic codegen library.
If you’re interested, please give them a star and try them out! ❤️
The Origin of the Story I recently read papers on physical simulation and wanted to reproduce them. I started with Stable Neo-Hookean Flesh Simulation, though the choice isn’t critical. Many modern physical simulations are implicit, requiring Newton’s method to solve optimization problems.
This involves:
Computing derivatives of the constitutive energy model (first-order gradient, second-order Hessian). Assembling a large, sparse Hessian from small, dense Hessian submatrices — a delicate task prone to hard-to-debug bugs. From Dynamic Deformables, I learned deriving these formulas is labor-intensive (even understanding the notation takes time). Searching for alternatives to avoid meticulous debugging, I found two solutions:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="english-post">
    <meta property="article:published_time" content="2025-10-02T15:15:21+08:00">
    <meta property="article:modified_time" content="2025-10-02T15:15:21+08:00">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Graphics">
    <meta property="article:tag" content="Math">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Raddy devlog: forward autodiff system">
  <meta name="twitter:description" content="TL;DR: I created Raddy, a forward autodiff library, and Symars, a symbolic codegen library.
If you’re interested, please give them a star and try them out! ❤️
The Origin of the Story I recently read papers on physical simulation and wanted to reproduce them. I started with Stable Neo-Hookean Flesh Simulation, though the choice isn’t critical. Many modern physical simulations are implicit, requiring Newton’s method to solve optimization problems.
This involves:
Computing derivatives of the constitutive energy model (first-order gradient, second-order Hessian). Assembling a large, sparse Hessian from small, dense Hessian submatrices — a delicate task prone to hard-to-debug bugs. From Dynamic Deformables, I learned deriving these formulas is labor-intensive (even understanding the notation takes time). Searching for alternatives to avoid meticulous debugging, I found two solutions:">

    <link rel="stylesheet" href="/css/root.css">
    <link rel="stylesheet" href="/css/bundle.css">

      <script src="/js/bundle.js"></script><script defer src="/js/search/flexsearch.compact.5e0de3b335e5c523c7cf45473dc43fccb6c75f64a9d59cc04a6eccbb7c25eb49.js" integrity="sha256-Xg3jszXlxSPHz0VHPcQ/zLbHX2Sp1ZzASm7Mu3wl60k="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>

<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="http://localhost:1313/" style="color: inherit;">Da1sypetals</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a href="/chinese-post/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a href="/chinese-post/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="http://localhost:1313/english-post/">
        <span itemprop="name">English-Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Raddy devlog: forward autodiff system</h1><time class="dim" datetime="2025-10-02T15:15:21&#43;08:00">October 2, 2025</time><div class="term-container"><div class="tag">
        <a href="http://localhost:1313/tags/rust/">#rust</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/graphics/">#graphics</a>
      </div><div class="tag">
        <a href="http://localhost:1313/tags/math/">#math</a>
      </div></ol></div>
  <section class="page-section"><p><strong>TL;DR:</strong> I created <a href="https://github.com/Da1sypetals/Raddy">Raddy</a>, a forward autodiff library, and <a href="https://github.com/Da1sypetals/Symars">Symars</a>, a symbolic codegen library.</p>
<p>If you&rsquo;re interested, please give them a star and try them out! ❤️</p>
<h2 id="the-origin-of-the-story">The Origin of the Story</h2>
<p>I recently read papers on physical simulation and wanted to reproduce them. I started with <a href="https://graphics.pixar.com/library/StableElasticity/paper.pdf">Stable Neo-Hookean Flesh Simulation</a>, though the choice isn&rsquo;t critical. Many modern physical simulations are implicit, requiring Newton&rsquo;s method to solve optimization problems.</p>
<p>This involves:</p>
<ul>
<li>Computing derivatives of the constitutive energy model (first-order gradient, second-order Hessian).</li>
<li>Assembling a large, sparse Hessian from small, dense Hessian submatrices — a delicate task prone to hard-to-debug bugs.</li>
</ul>
<p>From <a href="https://www.tkim.graphics/DYNAMIC_DEFORMABLES/">Dynamic Deformables</a>, I learned deriving these formulas is labor-intensive (even understanding the notation takes time). Searching for alternatives to avoid meticulous debugging, I found two solutions:</p>
<ul>
<li>Symbolic differentiation with code generation.</li>
<li>Automatic differentiation.</li>
</ul>
<p>Tools for the former include MATLAB or SymPy; for the latter, deep learning libraries like PyTorch or more suitable ones like <a href="https://github.com/patr-schm/TinyAD">TinyAD</a>.</p>
<p>Why TinyAD? Deep learning libraries differentiate at the tensor level, but I needed scalar-level differentiation for physical simulations. Tensor-level differentiation could lead to unplayable frame rates.</p>
<p>A problem arose: these tools are in the C++ toolchain, and I&rsquo;m not proficient in C++ (I know some kindergarten-level C++, but CMake and libraries like Eigen defeated me after three days of trying). So, I switched to Rust, a language I&rsquo;m more comfortable with. This was the start of all troubles…</p>
<h2 id="a-path-that-seems-simple">A Path That Seems Simple</h2>
<p>Rust lacks an automatic differentiation library for second-order Hessians (at least on crates.io). SymPy can generate Rust code, but it&rsquo;s buggy. Given the implementation complexity, I started with symbolic code generation, creating <a href="https://github.com/Da1sypetals/Symars">Symars</a>.</p>
<p>SymPy&rsquo;s symbolic expressions are tree-structured, with nodes as operators (<code>Add</code>, <code>Mul</code>, <code>Div</code>, <code>Sin</code>, etc.) or constants/symbols, and children as operands. Code generation involves depth-first traversal: compute child expressions, then the current node&rsquo;s expression based on its type. Base cases are constants or symbols.</p>
<p>I used the generated derivatives for a simple implicit spring-mass system, but debugging index errors in Hessian assembly was time-consuming.</p>
<h2 id="trying-the-untrodden-path-again">Trying the Untrodden Path Again</h2>
<p>To address this, I revisited automatic differentiation, aiming to adapt TinyAD for Rust.</p>
<h3 id="two-ways-to-walk-the-same-path">Two Ways to Walk the Same Path</h3>
<p>Initially, I considered two approaches:</p>
<ul>
<li>Write FFI bindings, as I don&rsquo;t know C++ well.</li>
<li>Replicate TinyAD&rsquo;s logic.</li>
</ul>
<p>Cloning TinyAD, I couldn&rsquo;t even pull dependencies or compile it. Examining the codebase, I found the core logic was ~1000 lines — manageable to replicate without running the project. Thus, <a href="https://github.com/Da1sypetals/Raddy">Raddy</a> was born.</p>
<h2 id="symbolic-diff--codegen-implementation">Symbolic diff &amp; Codegen: Implementation</h2>
<p>Implementation details:</p>
<ul>
<li>Each scalar in the differentiation chain carries a gradient and Hessian, increasing memory overhead. I avoided implementing the <code>Copy</code> trait, requiring explicit cloning.</li>
<li>Operator traits between <code>(&amp;)Type</code> and <code>(&amp;)Type</code> (four combinations) required repetitive code. I considered the following options:
<ul>
<li>Macros.</li>
<li>Python scripts for code generation.</li>
</ul>
</li>
</ul>
<p>Macros breaks <code>rust-analyzer</code> (somebody refuse to agree on this, but for me this is true) and I am rather unfamiliar with Rust&rsquo;s macro syntax, so I used Python scripts (in the <code>meta/</code> directory) for simple string concatenation.</p>
<ul>
<li>Testing: I verified derivatives by generating symbolic <code>grad</code> and <code>hessian</code> code with Symars, cross-validating against Raddy&rsquo;s results, ensuring test expressions covered all implemented methods. Symars performed reliably, without bugs.</li>
</ul>
<h2 id="what-about-sparse-matrices">What about sparse matrices</h2>
<p>Dense matrices store adjacent values contiguously, but sparse matrices (with millions of elements) don&rsquo;t. I implemented sparse Hessian assembly:</p>
<ul>
<li>Define a problem via the <code>Objective&lt;N&gt;</code> trait:</li>
<li>Specify problem size <code>N</code> (a compile-time constant for const generics).</li>
<li>Implement computation logic, e.g., a spring-mass system (Hooke&rsquo;s law, E=1/2 k x²):</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Objective<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">for</span> SpringEnergy {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">EvalArgs</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>; <span style="color:#75715e">// restlength
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eval</span>(<span style="color:#f92672">&amp;</span>self, variables: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">advec</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span>, restlen: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::EvalArgs) -&gt; <span style="color:#a6e22e">Ad</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// extract node positions from problem input:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> p1 <span style="color:#f92672">=</span> advec::<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>::new(variables[<span style="color:#ae81ff">0</span>].clone(), variables[<span style="color:#ae81ff">1</span>].clone());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> p2 <span style="color:#f92672">=</span> advec::<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>::new(variables[<span style="color:#ae81ff">2</span>].clone(), variables[<span style="color:#ae81ff">3</span>].clone());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> (p2 <span style="color:#f92672">-</span> p1).norm();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> e <span style="color:#f92672">=</span> make::val(<span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> self.k) <span style="color:#f92672">*</span> (len <span style="color:#f92672">-</span> make::val(<span style="color:#f92672">*</span>restlen)).powi(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        e
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Specify input components&rsquo; indices (<code>&amp;[[usize; N]]</code>).</li>
<li>Automatically assemble sparse <code>grad</code> and <code>hess</code> (handling index mapping).</li>
<li>Manually sum multiple <code>grad</code> and <code>hess</code> (simple matrix addition; triplet matrices are concatenated).</li>
</ul>
<p>Before tests, Raddy was 2.2k lines; after, it ballooned to 18k lines, showing LOC is a poor metric.</p>
<p>Finally, I wrote a demo for fun and as an example.</p>
<p><img src="../images/raddy-mass-spring.gif" alt=""></p>
<h2 id="conclusion">Conclusion</h2>
<p>Gains:</p>
<ul>
<li>Learned how automatic differentiation works.</li>
<li>First time using AI for documentation (it struggled with Rust syntax, producing test code with errors).</li>
<li>Happiness!</li>
</ul>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Da1sypetals</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>720 words</span>
    <span>5 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#the-origin-of-the-story">The Origin of the Story</a></li>
    <li><a href="#a-path-that-seems-simple">A Path That Seems Simple</a></li>
    <li><a href="#trying-the-untrodden-path-again">Trying the Untrodden Path Again</a>
      <ul>
        <li><a href="#two-ways-to-walk-the-same-path">Two Ways to Walk the Same Path</a></li>
      </ul>
    </li>
    <li><a href="#symbolic-diff--codegen-implementation">Symbolic diff &amp; Codegen: Implementation</a></li>
    <li><a href="#what-about-sparse-matrices">What about sparse matrices</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/english-post/try-impl-ipc/">Try To Implement IPC</a></li><li><a href="/english-post/snapviewer-3-optim/">SnapViewer Devlog #3: Optimizations</a></li><li><a href="/english-post/snapviewer-2-ui/">Snapviewer Devlog #2: UI</a></li><li><a href="/english-post/snapviewer/">SnapViewer: Faster PyTorch Memory Allocation Viewer</a></li><li><a href="/chinese-post/snapviewer-3-zh/">Snapviewer Devlog #3: 性能优化</a></li></ul></aside></div>
  </div>
</body>

</html>