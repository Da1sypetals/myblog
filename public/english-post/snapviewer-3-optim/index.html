<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">

<head>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['$', '$']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>SnapViewer Devlog #3: Optimizations | Da1sypetals</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="https://da1sypetals.github.io/english-post/snapviewer-3-optim/">
  <meta property="og:site_name" content="Da1sypetals">
  <meta property="og:title" content="SnapViewer Devlog #3: Optimizations">
  <meta property="og:description" content="Intro: Troubleshooting Memory and Speed Performance
Disclaimer: I develop and test primarily on Windows using the latest stable Rust toolchain and CPython 3.13.
1. Background and Motivation SnapViewer handles large memory snapshots effectively — for example, pickle files up to 1 GB and compressed snapshots up to 500 MB. However, when processing extremely large dumps (e.g., a 1.3 GB snapshot), we encountered serious memory and speed bottlenecks:
Format conversion (pickle → compressed JSON) triggered memory peaks around 30 GB. Data loading of the compressed JSON into Rust structures caused another ~30 GB spike. Frequent page faults and intense disk I/O (observed in Task Manager) made the application sluggish and prone to stalls. To address this, we applied a Profile-Guided Optimization (PGO) approach.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="english-post">
    <meta property="article:published_time" content="2025-10-02T15:01:14+08:00">
    <meta property="article:modified_time" content="2025-10-02T15:01:14+08:00">
    <meta property="article:tag" content="Torch">
    <meta property="article:tag" content="Deep-Learning">
    <meta property="article:tag" content="Rust">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="SnapViewer Devlog #3: Optimizations">
  <meta name="twitter:description" content="Intro: Troubleshooting Memory and Speed Performance
Disclaimer: I develop and test primarily on Windows using the latest stable Rust toolchain and CPython 3.13.
1. Background and Motivation SnapViewer handles large memory snapshots effectively — for example, pickle files up to 1 GB and compressed snapshots up to 500 MB. However, when processing extremely large dumps (e.g., a 1.3 GB snapshot), we encountered serious memory and speed bottlenecks:
Format conversion (pickle → compressed JSON) triggered memory peaks around 30 GB. Data loading of the compressed JSON into Rust structures caused another ~30 GB spike. Frequent page faults and intense disk I/O (observed in Task Manager) made the application sluggish and prone to stalls. To address this, we applied a Profile-Guided Optimization (PGO) approach.">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css" integrity="sha256-WesaBZ&#43;M1VjmQ3Xt4&#43;aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin="anonymous">

      <script src="/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js" integrity="sha256-zIrplS2/tzGv&#43;vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.5e0de3b335e5c523c7cf45473dc43fccb6c75f64a9d59cc04a6eccbb7c25eb49.js" integrity="sha256-Xg3jszXlxSPHz0VHPcQ/zLbHX2Sp1ZzASm7Mu3wl60k="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>

<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="https://da1sypetals.github.io/" style="color: inherit;">Da1sypetals</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a href="/chinese-post/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/english-post/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a href="/chinese-post/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/english-post/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sypetals.github.io/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sypetals.github.io/english-post/">
        <span itemprop="name">English-Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>SnapViewer Devlog #3: Optimizations</h1><time class="dim" datetime="2025-10-02T15:01:14&#43;08:00">October 2, 2025</time><div class="term-container"><div class="tag">
        <a href="https://da1sypetals.github.io/tags/torch/">#torch</a>
      </div><div class="tag">
        <a href="https://da1sypetals.github.io/tags/deep-learning/">#deep-learning</a>
      </div><div class="tag">
        <a href="https://da1sypetals.github.io/tags/rust/">#rust</a>
      </div></ol></div>
  <section class="page-section"><p><strong>Intro: Troubleshooting Memory and Speed Performance</strong></p>
<p><strong>Disclaimer:</strong> I develop and test primarily on Windows using the latest stable Rust toolchain and CPython 3.13.</p>
<h2 id="1-background-and-motivation">1. Background and Motivation</h2>
<p>SnapViewer handles large memory snapshots effectively — for example, pickle files up to 1 GB and compressed snapshots up to 500 MB. However, when processing extremely large dumps (e.g., a 1.3 GB snapshot), we encountered serious memory and speed bottlenecks:</p>
<ul>
<li>Format conversion (pickle → compressed JSON) triggered memory peaks around 30 GB.</li>
<li>Data loading of the compressed JSON into Rust structures caused another ~30 GB spike.</li>
</ul>
<p>Frequent page faults and intense disk I/O (observed in Task Manager) made the application sluggish and prone to stalls. To address this, we applied a Profile-Guided Optimization (PGO) approach.</p>
<h2 id="2-profile-guided-optimization">2. Profile-Guided Optimization</h2>
<p>PGO requires empirical profiling to identify the true hotspots. I began with memory profiling using the <a href="https://crates.io/crates/memory-stats">memory-stats</a> crate for lightweight inspection during early optimization stages. Then, I decomposed the data-loading pipeline into discrete steps:</p>
<ul>
<li>Reading the compressed file (heavy disk I/O)</li>
<li>Extracting the JSON string from the compressed stream</li>
<li>Deserializing the JSON into native Rust data structures</li>
<li>Populating an in-memory SQLite database for ad-hoc SQL queries</li>
<li>Building the triangle mesh on CPU</li>
<li>Initializing the rendering window (CPU-GPU transfer)</li>
</ul>
<p>Profiling revealed two major memory culprits: excessive cloning and multiple intermediate data structures. Below, I outline the optimizations.</p>
<h3 id="eliminating-redundant-clones">Eliminating Redundant Clones</h3>
<p>During rapid prototyping, calls to <code>.clone()</code> are convenient. But they are expensive. Profiling showed that cloning large vectors contributed significantly to the memory peak and CPU time.</p>
<ul>
<li><strong>First attempt:</strong> switch from cloned <code>Vec&lt;T&gt;</code> to borrowed <code>&amp;[T]</code> slices. This failed due to lifetime constraints.</li>
<li><strong>Final solution:</strong> use <code>Arc&lt;[T]&gt;</code>. Although I&rsquo;m not leveraging multithreading, <code>Arc</code> satisfies PyO3&rsquo;s requirements, while no significant overhead is observed in this context.</li>
</ul>
<p>This change alone reduced memory usage and improved throughput noticeably.</p>
<h3 id="early-deallocation-of-intermediate-structures">Early Deallocation of Intermediate Structures</h3>
<p>Constructing the triangle mesh involved several temporary representations:</p>
<ul>
<li>Raw allocation buffers</li>
<li>A list of triangles (vertices + face indices)</li>
<li>A CPU-side mesh structure</li>
<li>GPU upload buffers</li>
</ul>
<p>Each stage held onto its predecessor until the end of scope, inflating peak usage. To free these intermediates promptly, the following is implemented:</p>
<ul>
<li>Scoped blocks to limit lifetimes</li>
<li>Explicitly invoked <code>drop()</code> on unneeded buffers</li>
</ul>
<p>After these adjustments, peak memory dropped by roughly one-third.</p>
<h2 id="3-sharding-json-deserialization">3. Sharding JSON Deserialization</h2>
<p>Deserializing the call-stack JSON with over 50 000 entries spiked memory usage dramatically. To mitigate this:</p>
<ul>
<li>Shard the JSON data into chunks of at most 50 000 entries.</li>
<li>Deserialize each chunk independently.</li>
<li>Concatenate the resulting vectors.</li>
</ul>
<p>This streaming approach kept per-shard memory small, eliminating the previous giant allocation.</p>
<blockquote>
<p>It is worth noting that <code>serde_json::StreamDeserializer</code> can be another option worth trying.</p></blockquote>
<h2 id="4-redesigning-the-snapshot-format">4. Redesigning the Snapshot Format</h2>
<p>Even after the above optimizations, the call-stack data remained the largest in-memory component — duplicated once in Rust and again in the in-memory SQLite database.</p>
<p>To remove redundancy, I rethought what each representation serves:</p>
<ul>
<li><strong>Rust structures:</strong> display call stacks on screen upon user click.</li>
<li><strong>SQLite DB:</strong> serve ad-hoc SQL queries.</li>
</ul>
<p>Since SnapViewer is single-threaded and can tolerate occasional disk I/O, I split the snapshot into two files:</p>
<ul>
<li><strong>allocations.json:</strong> lightweight JSON with allocation timestamps and sizes.</li>
<li><strong>elements.db:</strong> SQLite database holding call-stack text (indexed by allocation index).</li>
</ul>
<p>These two files are zipped together. At runtime:</p>
<ul>
<li>Unzip the snapshot.</li>
<li>Load <code>allocations.json</code> into memory (small footprint).</li>
<li>Open <code>elements.db</code> on disk.</li>
<li>On click, query <code>elements.db</code> with <code>WHERE idx = &lt;allocation_index&gt;</code>.</li>
</ul>
<p>SQLite&rsquo;s efficient on-disk indices make these lookups fast, with no perceptible impact on frame rate.</p>
<h3 id="refactoring-the-conversion-script">Refactoring the Conversion Script</h3>
<p>I updated the snapshot-conversion script as follows:</p>
<ul>
<li>Parse the original snapshot format.</li>
<li>Bulk-insert call stacks into an in-memory SQLite database, then dump the DB as a byte stream.</li>
<li>Serialize allocation metadata to JSON.</li>
<li>Zip the JSON and DB byte stream.</li>
</ul>
<p>While conversion takes slightly longer, the resulting snapshot loads faster and uses a fraction of the memory.</p>
<h2 id="5-results-and-lessons">5. Results and Lessons</h2>
<p>After these optimizations, SnapViewer:</p>
<ul>
<li>No longer spikes to 60+ GB of RAM on large snapshots, since we do not load the entire call stack information into memory at all.</li>
<li>Starts up much faster.</li>
<li>Maintains smooth rendering, even with on-demand call-stack queries.</li>
</ul>
<p>What I learned:</p>
<ul>
<li>Do not always load everything into memory. When you overflow your memory, the performance of virtual memory swapping system is probably worse than you think.</li>
<li>When you need some mechanism to store most data on disk, but intelligentlly cache some of then in memory, SQLite should be a good start. It has its well-designed and industry-proven algorithm built into it.</li>
</ul>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Da1sypetals</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>741 words</span>
    <span>4 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#1-background-and-motivation">1. Background and Motivation</a></li>
    <li><a href="#2-profile-guided-optimization">2. Profile-Guided Optimization</a>
      <ul>
        <li><a href="#eliminating-redundant-clones">Eliminating Redundant Clones</a></li>
        <li><a href="#early-deallocation-of-intermediate-structures">Early Deallocation of Intermediate Structures</a></li>
      </ul>
    </li>
    <li><a href="#3-sharding-json-deserialization">3. Sharding JSON Deserialization</a></li>
    <li><a href="#4-redesigning-the-snapshot-format">4. Redesigning the Snapshot Format</a>
      <ul>
        <li><a href="#refactoring-the-conversion-script">Refactoring the Conversion Script</a></li>
      </ul>
    </li>
    <li><a href="#5-results-and-lessons">5. Results and Lessons</a></li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/english-post/snapviewer-2-ui/">Snapviewer Devlog #2: UI</a></li><li><a href="/english-post/snapviewer/">SnapViewer: Faster PyTorch Memory Allocation Viewer</a></li><li><a href="/chinese-post/snapviewer-3-zh/">Snapviewer Devlog #3: 性能优化</a></li><li><a href="/english-post/torch-cuda-ext/">Notes on Writing PyTorch CUDA Extensions</a></li><li><a href="/chinese-post/gnn-optim/">近期GNN Attention算子优化工作速览</a></li></ul></aside></div>
  </div>
</body>

</html>