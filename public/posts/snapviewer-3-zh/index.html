<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">

<head>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['$', '$']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Snapviewer Devlog #3: 性能优化 | Da1sypetals</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="https://da1sy-petals.vercel.app/posts/snapviewer-3-zh/">
  <meta property="og:site_name" content="Da1sypetals">
  <meta property="og:title" content="Snapviewer Devlog #3: 性能优化">
  <meta property="og:description" content="内存与速度性能问题排查 免责声明：我主要在 Windows 上使用最新的稳定版 Rust 工具链和 CPython 3.13 进行开发和测试。
1. 背景与动机 SnapViewer 能够高效处理大型内存快照——例如，支持高达 500 MB 的压缩快照。然而，在处理 1.3 GB的snapshot的时，我发现了严重的内存和速度瓶颈：
格式转换（pickle → 压缩 JSON）引发了约 30 GB 的内存峰值。 将压缩 JSON 加载到 Rust 数据结构中又引发了另一次约 30 GB 的内存激增。 频繁的 page fault 和强烈的磁盘 I/O（在任务管理器中观察到）导致应用程序响应迟缓，甚至频繁卡顿。为了解决这一问题，我们采用了 Profile-Guided Optimization（PGO，基于性能分析的优化）方法。
2. Profile-Guided Optimization（PGO） PGO 需要通过实证分析来识别真正的热点。我首先使用 memory-stats crate 进行内存分析，在早期优化阶段进行轻量级检查。随后，我将数据加载流水线拆解为若干离散步骤：
读取压缩文件（重度磁盘 I/O） 从压缩流中提取 JSON 字符串 将 JSON 反序列化为原生 Rust 数据结构 填充内存中的 SQLite 数据库以支持即席 SQL 查询 在 CPU 上构建三角网格（triangle mesh） 初始化渲染窗口（CPU-GPU 数据传输） 性能分析揭示了两个主要的内存问题：过度使用 clone 和多个中间数据结构。以下是我实施的优化措施。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-07T00:00:00+00:00">
    <meta property="article:tag" content="Torch">
    <meta property="article:tag" content="Deep-Learning">
    <meta property="article:tag" content="Rust">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Snapviewer Devlog #3: 性能优化">
  <meta name="twitter:description" content="内存与速度性能问题排查 免责声明：我主要在 Windows 上使用最新的稳定版 Rust 工具链和 CPython 3.13 进行开发和测试。
1. 背景与动机 SnapViewer 能够高效处理大型内存快照——例如，支持高达 500 MB 的压缩快照。然而，在处理 1.3 GB的snapshot的时，我发现了严重的内存和速度瓶颈：
格式转换（pickle → 压缩 JSON）引发了约 30 GB 的内存峰值。 将压缩 JSON 加载到 Rust 数据结构中又引发了另一次约 30 GB 的内存激增。 频繁的 page fault 和强烈的磁盘 I/O（在任务管理器中观察到）导致应用程序响应迟缓，甚至频繁卡顿。为了解决这一问题，我们采用了 Profile-Guided Optimization（PGO，基于性能分析的优化）方法。
2. Profile-Guided Optimization（PGO） PGO 需要通过实证分析来识别真正的热点。我首先使用 memory-stats crate 进行内存分析，在早期优化阶段进行轻量级检查。随后，我将数据加载流水线拆解为若干离散步骤：
读取压缩文件（重度磁盘 I/O） 从压缩流中提取 JSON 字符串 将 JSON 反序列化为原生 Rust 数据结构 填充内存中的 SQLite 数据库以支持即席 SQL 查询 在 CPU 上构建三角网格（triangle mesh） 初始化渲染窗口（CPU-GPU 数据传输） 性能分析揭示了两个主要的内存问题：过度使用 clone 和多个中间数据结构。以下是我实施的优化措施。">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css" integrity="sha256-WesaBZ&#43;M1VjmQ3Xt4&#43;aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin="anonymous">

      <script src="/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js" integrity="sha256-zIrplS2/tzGv&#43;vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.5e0de3b335e5c523c7cf45473dc43fccb6c75f64a9d59cc04a6eccbb7c25eb49.js" integrity="sha256-Xg3jszXlxSPHz0VHPcQ/zLbHX2Sp1ZzASm7Mu3wl60k="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>

<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="https://da1sy-petals.vercel.app/" style="color: inherit;">Da1sypetals</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    
  </div>
</div></header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sy-petals.vercel.app/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sy-petals.vercel.app/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Snapviewer Devlog #3: 性能优化</h1><time class="dim" datetime="2025-06-07T00:00:00&#43;00:00">June 7, 2025</time><div class="term-container"><div class="tag">
        <a href="https://da1sy-petals.vercel.app/tags/torch/">#torch</a>
      </div><div class="tag">
        <a href="https://da1sy-petals.vercel.app/tags/deep-learning/">#deep-learning</a>
      </div><div class="tag">
        <a href="https://da1sy-petals.vercel.app/tags/rust/">#rust</a>
      </div></ol></div>
  <section class="page-section"><h1 id="内存与速度性能问题排查">内存与速度性能问题排查</h1>
<p><strong>免责声明</strong>：我主要在 Windows 上使用最新的稳定版 Rust 工具链和 CPython 3.13 进行开发和测试。</p>
<h2 id="1-背景与动机">1. 背景与动机</h2>
<p>SnapViewer 能够高效处理大型内存快照——例如，支持高达 500 MB 的压缩快照。然而，在处理 1.3 GB的snapshot的时，我发现了严重的内存和速度瓶颈：</p>
<ul>
<li>格式转换（pickle → 压缩 JSON）引发了约 30 GB 的内存峰值。</li>
<li>将压缩 JSON 加载到 Rust 数据结构中又引发了另一次约 30 GB 的内存激增。</li>
</ul>
<p>频繁的 page fault 和强烈的磁盘 I/O（在任务管理器中观察到）导致应用程序响应迟缓，甚至频繁卡顿。为了解决这一问题，我们采用了 Profile-Guided Optimization（PGO，基于性能分析的优化）方法。</p>
<h2 id="2-profile-guided-optimizationpgo">2. Profile-Guided Optimization（PGO）</h2>
<p>PGO 需要通过实证分析来识别真正的热点。我首先使用 <a href="https://crates.io/crates/memory-stats">memory-stats</a> crate 进行内存分析，在早期优化阶段进行轻量级检查。随后，我将数据加载流水线拆解为若干离散步骤：</p>
<ul>
<li>读取压缩文件（重度磁盘 I/O）</li>
<li>从压缩流中提取 JSON 字符串</li>
<li>将 JSON 反序列化为原生 Rust 数据结构</li>
<li>填充内存中的 SQLite 数据库以支持即席 SQL 查询</li>
<li>在 CPU 上构建三角网格（triangle mesh）</li>
<li>初始化渲染窗口（CPU-GPU 数据传输）</li>
</ul>
<p>性能分析揭示了两个主要的内存问题：过度使用 <code>clone</code> 和多个中间数据结构。以下是我实施的优化措施。</p>
<h3 id="消除冗余的-clone">消除冗余的 Clone</h3>
<p>在快速原型开发阶段，调用 <code>.clone()</code> 非常方便，但代价高昂。性能分析显示，克隆大型 <code>Vec</code> 显著加剧了内存峰值和 CPU 时间。</p>
<ul>
<li><strong>首次尝试</strong>：将对 <code>Vec&lt;T&gt;</code> 的 <code>clone()</code> 改为借用的 <code>&amp;[T]</code> 切片。但由于生命周期约束无法做到.</li>
<li><strong>最终方案</strong>：改用 <code>Arc&lt;[T]&gt;</code>。尽管我并未使用多线程，但 <code>Arc</code> 满足了 PyO3 的要求，且在此场景中未观察到明显开销。</li>
</ul>
<p>仅此一项改动就显著降低了内存使用, 降低了启动耗时。</p>
<h3 id="提前释放中间结构">提前释放中间结构</h3>
<p>构建三角网格涉及多个临时表示形式：</p>
<ul>
<li>原始分配缓冲区</li>
<li>三角形列表（顶点 + 面索引）</li>
<li>CPU 端的网格结构</li>
<li>GPU 上传缓冲区</li>
</ul>
<p>每个阶段都会保留其前驱数据直至作用域结束，从而推高了峰值内存占用。为及时释放这些中间数据，我们采取了以下措施：</p>
<ul>
<li>使用作用域块（scoped blocks）限制生命周期</li>
<li>对不再需要的缓冲区显式调用 <code>drop()</code></li>
</ul>
<p>经过这些调整，峰值内存大约减少了三分之一。</p>
<h2 id="3-分片处理-json-反序列化">3. 分片处理 JSON 反序列化</h2>
<p>对包含超过 50,000 个条目的调用栈 JSON 进行反序列化时，内存使用急剧飙升。为缓解此问题：</p>
<ul>
<li>将 JSON 数据分片，每片最多包含 50,000 个条目。</li>
<li>独立反序列化每个分片。</li>
<li>合并所得到的<code>Vec</code>。</li>
</ul>
<p>这种流式处理方法使每个分片的内存占用保持在较低水平，避免了之前的大规模单次分配。</p>
<blockquote>
<p>值得注意的是，<code>serde_json::StreamDeserializer</code> 是另一个值得尝试的选项。</p></blockquote>
<h2 id="4-重新设计快照格式">4. 重新设计快照格式</h2>
<p>即使经过上述优化，调用栈数据仍然是内存中最大的组件——在 Rust 中和内存 SQLite 数据库中各存一份，造成重复。</p>
<p>为消除冗余，我重新思考了每种表示形式的用途：</p>
<ul>
<li><strong>Rust 结构</strong>：用户点击时在屏幕上显示调用栈。</li>
<li><strong>SQLite 数据库</strong>：支持即席 SQL 查询。</li>
</ul>
<p>由于 SnapViewer 是单线程的，且可容忍偶尔的磁盘 I/O，我将快照拆分为两个文件：</p>
<ul>
<li><strong>allocations.json</strong>：轻量级 JSON，包含分配时间戳和大小。</li>
<li><strong>elements.db</strong>：SQLite 数据库，存储调用栈文本（按分配索引建立索引）。</li>
</ul>
<p>这两个文件被一起压缩打包。运行时：</p>
<ul>
<li>解压快照。</li>
<li>将 <code>allocations.json</code> 加载到内存（占用很小）。</li>
<li>打开磁盘上的 <code>elements.db</code>。</li>
<li>用户点击时，通过 <code>WHERE idx = &lt;allocation_index&gt;</code> 查询 <code>elements.db</code>。</li>
</ul>
<p>SQLite 高效的磁盘索引使这些查询非常迅速，对帧率几乎没有可感知的影响。</p>
<h3 id="重构转换脚本">重构转换脚本</h3>
<p>我对快照转换脚本进行了如下更新：</p>
<ul>
<li>解析原始快照格式。</li>
<li>将调用栈批量插入内存 SQLite 数据库，然后将数据库转储为字节流。</li>
<li>将分配元数据序列化为 JSON。</li>
<li>将 JSON 与数据库字节流一起压缩。</li>
</ul>
<p>虽然转换过程略慢，但生成的快照加载更快，且内存占用大幅降低。</p>
<h2 id="5-成果与经验总结">5. 成果与经验总结</h2>
<p>经过这些优化，SnapViewer 实现了以下改进：</p>
<ul>
<li>不再因加载大型快照而触发 60+ GB 的内存峰值，因为我们完全不再将整个调用栈信息加载到内存中。</li>
<li>启动速度显著提升。</li>
<li>即使进行按需调用栈查询，渲染依然流畅。</li>
</ul>
<p>我学到的经验：</p>
<ul>
<li>不要总是把所有数据都加载到内存中。当你耗尽物理内存时，虚拟内存交换系统的性能可能比你想象的还要差。</li>
<li>当你需要将大部分数据存储在磁盘上，同时智能地缓存部分数据到内存时，SQLite 是一个好的选择。它内置了经过工业验证的高效算法。</li>
</ul>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Da1sypetals</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>195 words</span>
    <span>4 - 6 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#1-背景与动机">1. 背景与动机</a></li>
    <li><a href="#2-profile-guided-optimizationpgo">2. Profile-Guided Optimization（PGO）</a>
      <ul>
        <li><a href="#消除冗余的-clone">消除冗余的 Clone</a></li>
        <li><a href="#提前释放中间结构">提前释放中间结构</a></li>
      </ul>
    </li>
    <li><a href="#3-分片处理-json-反序列化">3. 分片处理 JSON 反序列化</a></li>
    <li><a href="#4-重新设计快照格式">4. 重新设计快照格式</a>
      <ul>
        <li><a href="#重构转换脚本">重构转换脚本</a></li>
      </ul>
    </li>
    <li><a href="#5-成果与经验总结">5. 成果与经验总结</a></li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/posts/lsm/">Lsm Tree 实现备注</a></li></ul></aside></div>
  </div>
</body>

</html>