<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">

<head>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
    MathJax = {
        tex: {
            displayMath: [['\\[', '\\]'], ['$$', '$$']],  
            inlineMath: [['$', '$']]                  
        },
        loader: {
            load: ['ui/safe']
        },
    };
</script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Lsm Tree 实现备注 | Da1sypetals</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="https://da1sypetals.github.io/posts/lsm/">
  <meta property="og:site_name" content="Da1sypetals">
  <meta property="og:title" content="Lsm Tree 实现备注">
  <meta property="og:description" content="Lsm Tree 是一种内存-磁盘的层级式数据结构，常用于实现写多读少的存储引擎。
这是我实现 Lsmkv 的时候记录的备注.
组件 内存部分 磁盘部分 WAL 总体 初始化 需要 init flush thread。flush thread 的工作流程:
等待 flush 信号量被 notify,获取一个 compact 信号量资源 启动一个 sstwriter,写入这个 memtable 一个 memtable 对一个 sst 等到写入 sst 写完之后,才进行: 从 frozen memtables、frozen memtable sizes 里面删除这个 memtable 从 wal 里面删除这个 memtable 对应的 wal update manifest Try Freeze 如果当前大小 &gt; freeze size 那么就 freeze;进一步如果所有 frozen memtable 大小之和 &gt; flush threshold,那么就 set flush signal。
写操作 写 memtable 写 WAL try freeze 内存部分 Put 添加到 memtable; 更新 size。 size 不需要特别精确,只需要是一个大致的值即可。 Delete 添加一个 tomb 标记到 memtable Get 从 active memtable 中获取 从 new 到 old 遍历所有的 inactive memtable,获取。 磁盘部分 compact 信号量 二元信号量。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-01T00:00:00+00:00">
    <meta property="article:tag" content="Database">
    <meta property="article:tag" content="Rust">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Lsm Tree 实现备注">
  <meta name="twitter:description" content="Lsm Tree 是一种内存-磁盘的层级式数据结构，常用于实现写多读少的存储引擎。
这是我实现 Lsmkv 的时候记录的备注.
组件 内存部分 磁盘部分 WAL 总体 初始化 需要 init flush thread。flush thread 的工作流程:
等待 flush 信号量被 notify,获取一个 compact 信号量资源 启动一个 sstwriter,写入这个 memtable 一个 memtable 对一个 sst 等到写入 sst 写完之后,才进行: 从 frozen memtables、frozen memtable sizes 里面删除这个 memtable 从 wal 里面删除这个 memtable 对应的 wal update manifest Try Freeze 如果当前大小 &gt; freeze size 那么就 freeze;进一步如果所有 frozen memtable 大小之和 &gt; flush threshold,那么就 set flush signal。
写操作 写 memtable 写 WAL try freeze 内存部分 Put 添加到 memtable; 更新 size。 size 不需要特别精确,只需要是一个大致的值即可。 Delete 添加一个 tomb 标记到 memtable Get 从 active memtable 中获取 从 new 到 old 遍历所有的 inactive memtable,获取。 磁盘部分 compact 信号量 二元信号量。">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css" integrity="sha256-WesaBZ&#43;M1VjmQ3Xt4&#43;aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin="anonymous">

      <script src="/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js" integrity="sha256-zIrplS2/tzGv&#43;vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.5e0de3b335e5c523c7cf45473dc43fccb6c75f64a9d59cc04a6eccbb7c25eb49.js" integrity="sha256-Xg3jszXlxSPHz0VHPcQ/zLbHX2Sp1ZzASm7Mu3wl60k="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>

<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="https://da1sypetals.github.io/" style="color: inherit;">Da1sypetals</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >文章</a>
    </div>
    <div class="nav-item">
      <a href="/english-post/"
      >en-Posts</a>
    </div>
    <div class="nav-item">
      <a href="https://singings.netlify.app"
      >歌单</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >关于我</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sypetals.github.io/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://da1sypetals.github.io/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Lsm Tree 实现备注</h1><time class="dim" datetime="2025-03-01T00:00:00&#43;00:00">March 1, 2025</time><div class="term-container"><div class="tag">
        <a href="https://da1sypetals.github.io/tags/database/">#database</a>
      </div><div class="tag">
        <a href="https://da1sypetals.github.io/tags/rust/">#rust</a>
      </div></ol></div>
  <section class="page-section"><p>Lsm Tree 是一种内存-磁盘的层级式数据结构，常用于实现写多读少的存储引擎。</p>
<p>这是我实现 <a href="https://github.com/Da1sypetals/Lsmkv">Lsmkv</a> 的时候记录的备注.</p>
<h2 id="组件">组件</h2>
<ul>
<li>内存部分</li>
<li>磁盘部分</li>
<li>WAL</li>
</ul>
<h2 id="总体">总体</h2>
<h2 id="初始化">初始化</h2>
<p>需要 init flush thread。flush thread 的工作流程:</p>
<ol>
<li>等待 flush 信号量被 notify,获取一个 compact 信号量资源</li>
<li>启动一个 sstwriter,写入这个 memtable
<ul>
<li>一个 memtable 对一个 sst</li>
</ul>
</li>
<li>等到写入 sst 写完之后,才进行:
<ul>
<li>从 frozen memtables、frozen memtable sizes 里面删除这个 memtable</li>
<li>从 wal 里面删除这个 memtable 对应的 wal</li>
<li>update manifest</li>
</ul>
</li>
</ol>
<h2 id="try-freeze">Try Freeze</h2>
<p>如果当前大小 &gt; freeze size 那么就 freeze;进一步如果所有 frozen memtable 大小之和 &gt; flush threshold,那么就 set flush signal。</p>
<h2 id="写操作">写操作</h2>
<ol>
<li>写 memtable</li>
<li>写 WAL</li>
<li>try freeze</li>
</ol>
<h2 id="内存部分">内存部分</h2>
<h3 id="put">Put</h3>
<ol>
<li>添加到 memtable;</li>
<li>更新 size。
<ul>
<li>size 不需要特别精确,只需要是一个大致的值即可。</li>
</ul>
</li>
</ol>
<h3 id="delete">Delete</h3>
<ol>
<li>添加一个 tomb 标记到 memtable</li>
</ol>
<h3 id="get">Get</h3>
<ol>
<li>从 active memtable 中获取</li>
<li>从 new 到 old 遍历所有的 inactive memtable,获取。</li>
</ol>
<h2 id="磁盘部分">磁盘部分</h2>
<h3 id="compact-信号量">compact 信号量</h3>
<p>二元信号量。</p>
<ul>
<li>需要 compact 的时候,添加资源</li>
<li>compact thread 开始 compact 的时候,消耗资源。</li>
</ul>
<h3 id="初始化-1">初始化</h3>
<p>如果 auto compact 开启,初始化的时候需要 init compact thread:</p>
<h3 id="level">Level</h3>
<p>存储这个 level 所有文件对应的文件路径,装在 sst reader 里面</p>
<h3 id="get-没有-delete-put">Get (没有 delete, put)</h3>
<p>从低到高,从新到旧,调用 sst 的 get 方法,获取 record。否则返回 none。</p>
<h3 id="init-compact-thread">Init Compact Thread</h3>
<p>Compact thread:</p>
<ol>
<li>等待 compact 信号量</li>
<li>依次查看每一层:如果这一层大小超过 threshold,就合并到下一层,否则就提前返回。</li>
</ol>
<h3 id="compact">Compact</h3>
<p>以 L0 -&gt; L1 为例:
从前到后遍历所有的 kv-pair,同时维护:</p>
<ol>
<li>keys_outdated
<ul>
<li>同一个 key,timetsamp 小于 oldest marker 的 kv pair 只需要保留一个。</li>
<li>keys_outdated 记录所有(出现过的,且 timestamp 小于 oldest marker)的 key</li>
</ul>
</li>
<li>L1 sst size 每达到一定值就关闭当前 sst,新开一个新的 sst。</li>
<li>更新 manifest。</li>
</ol>
<h3 id="sst-writer">SST writer</h3>
<p>配置 max block size。</p>
<ul>
<li>每个 block 的开头一个 key 会添加到 index 中;</li>
<li>搜索这个 sst 的时候,会先对 index 进行二分查找;</li>
<li>在 block 之内采用线性搜索。</li>
</ul>
<p>fpr,用于构建 bloom filter.</p>
<h4 id="写入">写入</h4>
<ol>
<li>遍历所有的 kv pair:
<ul>
<li>userkey(不含 timestamp)添加到 bloom filter;</li>
<li>block 写入当前 kv;</li>
<li>如果当前 block 大小超过 max block size,就开启一个新的 block,然后写入对应的 index(内存)</li>
</ul>
</li>
<li>将 index 和 bloom filter 写磁盘。</li>
</ol>
<h4 id="sst-reader-查找-getkey-timestamp">SST reader 查找: Get(key, timestamp)</h4>
<ol>
<li>查 bloom filter,如果不存在就返回。</li>
<li>将 index 整个载入内存中,进行二分查找,得到对应 key-timestamp 所在的区间。如果 out of bounds 就返回。</li>
<li>按照查找到的区间,读磁盘。</li>
</ol>
<h2 id="mvcc">MVCC</h2>
<h3 id="key-排布问题">key 排布问题</h3>
<h4 id="struct-key">struct Key</h4>
<ul>
<li>bytes</li>
<li>timestamp: u64</li>
</ul>
<p>比较: key1 &lt; key2:</p>
<ul>
<li>key1.bytes &lt; key2.bytes (字典序);</li>
<li>或者: key1.bytes == key2.bytes,而且 key1.timestamp &gt; key2.timestamp</li>
</ul>
<h4 id="为什么这样比较">为什么这样比较?</h4>
<p>在进行查询 Get(userkey, timestamp) 的时候,我们需要的是:</p>
<ul>
<li>userkey 匹配</li>
<li>timestamp 小于查询的 timestamp,且尽可能大</li>
</ul>
<p>因此,我们将</p>
<ul>
<li>userkey 升序排序</li>
<li>timestamp 降序排序</li>
</ul>
<p>在搜索 memtable(skiplist)的时候,或者对 index 进行二分查找的时候,就可以:</p>
<ol>
<li>直接使用 lower_bound,查找大于等于自己的第一个元素</li>
<li>如果 userkey 匹配,说明是 timestamp 小于当前 timestamp 的,timestamp 最大的记录,返回;</li>
<li>如果 userkey 不匹配,说明不存在 timestamp 小于当前 timestamp 的记录,返回(未找到)。</li>
</ol>
<h2 id="transaction">Transaction</h2>
<h3 id="数据结构">数据结构</h3>
<p>一个内存 tempmap,用来存储 transaction 已经写,但是未提交的内容。
创建的时候,从 tree 获取:</p>
<ul>
<li>start timestamp,作为查询的 timestamp</li>
<li>transaction id</li>
</ul>
<p>然后写入 transaction start 到 WAL</p>
<h3 id="putdelete">Put,Delete</h3>
<p>写 tempmap,写 WAL</p>
<h3 id="get-1">Get</h3>
<p>使用 start timestamp,先查 tempmap,再查 tree。</p>
<h3 id="commit">Commit</h3>
<ol>
<li>从 tree 获取一个 commit timestamp;</li>
<li>写 WAL,记录 transaction id 和 commit timestamp。
<ul>
<li>在 replay 的时候,把 transaction id 和 commit timestamp 对应起来就可以知道 transaction 里面的 写操作 对应的 timestamp</li>
</ul>
</li>
<li>调用 tree.active_memtable 的 API,将 transaction 的所有数据写入 tree 的 memtable。</li>
</ol>
<h3 id="wal">WAL</h3>
<p>看到 transaction start,先将 transaction 暂存到内存中:</p>
<ul>
<li>如果在 replay 结束之前看到了 transaction end,就将改动写入 tree 中(redo)。</li>
<li>否则放弃,视为没完成的事务(undo)</li>
</ul>
<h2 id="踩坑">踩坑:</h2>
<ol>
<li>Resource deadlock avoided (os error 35),可能是一个 thread 持有了自己的 joinhandle 并且 join 了自己;使用 maybe join 解决,即判断当前线程和 joinhandle 的线程是否一致,如果一致就不用 join。</li>
<li>死锁问题: wal 和 mem 都有锁,必须 按照同一顺序获取 才不会出现死锁。</li>
</ol>
<h2 id="bloom-filter-细节">Bloom filter 细节</h2>
<blockquote>
<p>本部分由 Deepseek 辅助写作</p></blockquote>
<p>该 Bloom filter 算法的主要步骤如下:</p>
<ol>
<li>
<p>参数计算:</p>
<ul>
<li>根据预期元素数量 n 和可接受误判率 p,通过公式计算最优位数 m 和哈希函数数量 k:
<!-- - m = ⌈-n·ln(p)/(ln2)^2⌉ -->
<ul>
<li>$ m=\lceil-n \dfrac{\ln(p)}{\ln(2) ^ 2}\rceil $</li>
</ul>
<!-- - k = ⌈(m/n)·ln2⌉ -->
<ul>
<li>$ k=\lceil\dfrac{m}{n}\ln(2)\rceil $</li>
</ul>
</li>
<li>当直接指定参数时,使用给定的位数和哈希函数数量</li>
</ul>
</li>
<li>
<p>哈希生成:</p>
<ul>
<li>使用 64 位指纹哈希(farmhash)生成初始哈希值 h</li>
<li>通过位运算构造增量值 <code>delta = (h &gt;&gt; 33) | (h &lt;&lt; 31)</code></li>
<li>采用双重哈希技术,通过循环叠加 delta 生成 k 个不同的位位置: $ h_i \equiv h + i \cdot delta \pmod m , 0 \leq i \lt k $</li>
</ul>
</li>
<li>
<p>数据插入:</p>
<ul>
<li>对输入 key 进行哈希计算得到初始 h 和 delta</li>
<li>循环 k 次生成位位置,将位数组中对应位置设为 1</li>
<li>采用位操作: byte_index = position/8,bit_mask = 1 &laquo; (position%8)</li>
</ul>
</li>
<li>
<p>存在性检测:</p>
<ul>
<li>重复插入时的哈希计算过程</li>
<li>检查所有 k 个对应位是否均为 1</li>
<li>任一位置为 0 则判定不存在,全部为 1 时判定可能存在</li>
</ul>
</li>
<li>
<p>数据持久化:</p>
<ul>
<li>序列化时附加 CRC32 校验和</li>
<li>反序列化时验证校验和与数据完整性</li>
</ul>
</li>
</ol>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Da1sypetals</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>510 words</span>
    <span>5 - 7 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#组件">组件</a></li>
    <li><a href="#总体">总体</a></li>
    <li><a href="#初始化">初始化</a></li>
    <li><a href="#try-freeze">Try Freeze</a></li>
    <li><a href="#写操作">写操作</a></li>
    <li><a href="#内存部分">内存部分</a>
      <ul>
        <li><a href="#put">Put</a></li>
        <li><a href="#delete">Delete</a></li>
        <li><a href="#get">Get</a></li>
      </ul>
    </li>
    <li><a href="#磁盘部分">磁盘部分</a>
      <ul>
        <li><a href="#compact-信号量">compact 信号量</a></li>
        <li><a href="#初始化-1">初始化</a></li>
        <li><a href="#level">Level</a></li>
        <li><a href="#get-没有-delete-put">Get (没有 delete, put)</a></li>
        <li><a href="#init-compact-thread">Init Compact Thread</a></li>
        <li><a href="#compact">Compact</a></li>
        <li><a href="#sst-writer">SST writer</a></li>
      </ul>
    </li>
    <li><a href="#mvcc">MVCC</a>
      <ul>
        <li><a href="#key-排布问题">key 排布问题</a></li>
      </ul>
    </li>
    <li><a href="#transaction">Transaction</a>
      <ul>
        <li><a href="#数据结构">数据结构</a></li>
        <li><a href="#putdelete">Put,Delete</a></li>
        <li><a href="#get-1">Get</a></li>
        <li><a href="#commit">Commit</a></li>
        <li><a href="#wal">WAL</a></li>
      </ul>
    </li>
    <li><a href="#踩坑">踩坑:</a></li>
    <li><a href="#bloom-filter-细节">Bloom filter 细节</a></li>
  </ul>
</nav></aside></div>
  </div>
</body>

</html>